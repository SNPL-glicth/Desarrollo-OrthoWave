# üîê Flujo de Autenticaci√≥n - Sistema Orto-Whave

Este documento explica en detalle el funcionamiento del sistema de autenticaci√≥n de la aplicaci√≥n Orto-Whave, incluyendo registro, inicio de sesi√≥n, verificaci√≥n por email y el uso de JWT (JSON Web Tokens).

## üìã Tabla de Contenidos

1. [Introducci√≥n](#introducci√≥n)
2. [¬øQu√© son los JWT?](#qu√©-son-los-jwt)
3. [Flujo de Registro](#flujo-de-registro)
4. [Flujo de Inicio de Sesi√≥n](#flujo-de-inicio-de-sesi√≥n)
5. [Archivos Involucrados](#archivos-involucrados)
6. [Diagramas de Flujo](#diagramas-de-flujo)
7. [Seguridad](#seguridad)

## üåü Introducci√≥n

El sistema de autenticaci√≥n de Orto-Whave utiliza una arquitectura basada en **JWT (JSON Web Tokens)** para manejar la autenticaci√≥n y autorizaci√≥n de usuarios. El flujo incluye:

- **Registro** con verificaci√≥n por email
- **Inicio de sesi√≥n** con generaci√≥n de tokens JWT
- **Gesti√≥n de roles** (admin, doctor, paciente)
- **Protecci√≥n de rutas** mediante guards
- **Persistencia de sesi√≥n** en localStorage

---

## üéØ ¬øQu√© son los JWT?

### Definici√≥n
**JWT (JSON Web Token)** es un est√°ndar abierto (RFC 7519) que define una forma compacta y segura de transmitir informaci√≥n entre partes como un objeto JSON. Esta informaci√≥n puede ser verificada y confiable porque est√° firmada digitalmente.

### Estructura de un JWT
Un JWT est√° compuesto por tres partes separadas por puntos (`.`):

```
[HEADER].[PAYLOAD].[SIGNATURE]
```

#### 1. Header (Encabezado)
```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```
- `alg`: Algoritmo usado para firmar el token
- `typ`: Tipo de token

#### 2. Payload (Carga √∫til)
```json
{
  "email": "usuario@example.com",
  "sub": "123",
  "rol": "paciente",
  "iat": 1635724800,
  "exp": 1635811200
}
```
- `sub`: Subject (ID del usuario)
- `iat`: Issued At (cuando se cre√≥)
- `exp`: Expiration Time (cuando expira)
- Datos personalizados (email, rol, etc.)

#### 3. Signature (Firma)
```javascript
HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  secret
)
```

### ¬øC√≥mo funcionan los JWT en nuestra aplicaci√≥n?

1. **Generaci√≥n**: El servidor crea el JWT despu√©s de validar credenciales
2. **Env√≠o**: Se env√≠a al frontend en la respuesta de login
3. **Almacenamiento**: Se guarda en localStorage del navegador
4. **Uso**: Se incluye en el header `Authorization: Bearer <token>` en cada petici√≥n
5. **Validaci√≥n**: El servidor verifica la firma en cada petici√≥n protegida

### Ventajas de JWT
- ‚úÖ **Stateless**: No requiere almacenamiento en el servidor
- ‚úÖ **Seguro**: Firmado digitalmente
- ‚úÖ **Compacto**: Tama√±o peque√±o
- ‚úÖ **Informaci√≥n incluida**: Contiene datos del usuario
- ‚úÖ **Escalable**: Perfecto para aplicaciones distribuidas

---

## üìù Flujo de Registro

### Paso a Paso

#### 1. Frontend - Formulario de Registro
**Archivo**: `frontend/my-app/src/pages/RegisterPage.jsx`

```javascript
const userData = {
  nombre: formData.firstName.trim(),
  apellido: formData.lastName.trim(),
  email: formData.email.trim().toLowerCase(),
  telefono: formData.phone.trim(),
  password: formData.password,
  rolId: 3 // Siempre paciente para registro p√∫blico
};

const response = await register(userData);
```

**Validaciones del frontend:**
- ‚úÖ Todos los campos requeridos
- ‚úÖ Email v√°lido
- ‚úÖ Tel√©fono m√≠nimo 10 d√≠gitos
- ‚úÖ Contrase√±a m√≠nimo 6 caracteres
- ‚úÖ Confirmaci√≥n de contrase√±a

#### 2. Servicio de Autenticaci√≥n
**Archivo**: `frontend/my-app/src/services/auth.service.ts`

```javascript
async register(userData: RegisterData): Promise<RegisterResponse> {
  try {
    const response = await api.post('/auth/register', userData);
    return response.data;
  } catch (error) {
    // Manejo de errores...
  }
}
```

#### 3. Backend - Controlador de Autenticaci√≥n
**Archivo**: `backend/src/auth/auth.controller.ts`

```typescript
@Post('register')
async register(@Body(ValidationPipe) registerDto: RegisterDto) {
  return this.authService.register(registerDto);
}
```

#### 4. Backend - Servicio de Autenticaci√≥n
**Archivo**: `backend/src/auth/auth.service.ts`

**Proceso interno:**

1. **Validaci√≥n de datos**
```typescript
if (!userData.nombre || !userData.apellido || !userData.email || !userData.password) {
  throw new BadRequestException('Todos los campos son obligatorios.');
}
```

2. **Verificar email √∫nico**
```typescript
const existingUser = await this.usersRepository.findOne({
  where: { email: userData.email },
});

if (existingUser) {
  throw new ConflictException('El correo electr√≥nico ya est√° registrado');
}
```

3. **Generar c√≥digo de verificaci√≥n**
```typescript
const randomNum = Math.floor(100000 + Math.random() * 900000);
const verificationCode = randomNum.toString().padStart(6, '0');
```

4. **Hashear contrase√±a**
```typescript
const saltRounds = 12;
const hashedPassword = await bcrypt.hash(userData.password, saltRounds);
```

5. **Crear usuario**
```typescript
const newUser = this.usersRepository.create({
  ...userData,
  password: hashedPassword,
  rolId: userData.rolId || 3,
  isVerified: false,
  verificationCode,
  isApproved: false,
  approvalStatus: 'pending',
});

await this.usersRepository.save(newUser);
```

6. **Enviar email de verificaci√≥n**
```typescript
await this.mailerService.sendMail({
  to: userData.email,
  subject: 'C√≥digo de verificaci√≥n - Orto-Whave',
  template: './verification-code',
  context: {
    name: userData.nombre,
    verificationCode: verificationCode,
    email: userData.email,
  },
});
```

#### 5. Respuesta y Redirecci√≥n
```typescript
return {
  message: 'Usuario registrado exitosamente. Hemos enviado un c√≥digo de verificaci√≥n a tu correo electr√≥nico.',
  email: userData.email,
  requiresVerification: true,
};
```

El frontend recibe esta respuesta y redirige a:
```javascript
if (response && response.requiresVerification === true) {
  navigate(`/verify-email?email=${encodeURIComponent(userData.email)}`);
}
```

### Verificaci√≥n por Email

#### Archivo de Verificaci√≥n: `frontend/my-app/src/pages/VerifyEmailPage.jsx`

El usuario ingresa el c√≥digo de 6 d√≠gitos recibido por email:

```javascript
const response = await authService.verifyCode(email, code);
```

#### Backend - Verificaci√≥n de C√≥digo
**Archivo**: `backend/src/auth/auth.service.ts`

```typescript
async verifyCode(email: string, code: string) {
  const user = await this.usersRepository.findOne({ 
    where: { email },
    relations: ['rol']
  });

  // Validar c√≥digo
  if (storedCode !== receivedCode) {
    throw new UnauthorizedException('C√≥digo de verificaci√≥n incorrecto');
  }
  
  // Marcar como verificado
  user.isVerified = true;
  user.verificationCode = null;
  await this.usersRepository.save(user);
  
  return { message: 'Cuenta verificada exitosamente.' };
}
```

---

## üîë Flujo de Inicio de Sesi√≥n

### Paso a Paso

#### 1. Frontend - Formulario de Login
**Archivo**: `frontend/my-app/src/pages/LoginPage.jsx`

```javascript
const response = await login(email, password);

// Redirecci√≥n basada en rol
const redirectPath = getRedirectPathByRole(response.user.rol);
navigate(redirectPath, { replace: true });
```

#### 2. Context de Autenticaci√≥n
**Archivo**: `frontend/my-app/src/context/AuthContext.tsx`

```typescript
const login = async (email: string, password: string) => {
  const response = await authService.login(email, password);
  const userWithRole: User = {
    ...response.user,
    rol: mapRoleToValidRole(response.user.rol || ''),
    id: response.user.id.toString(),
  };
  
  setUser(userWithRole);
  setToken(response.access_token);
  setIsAuthenticated(true);
  
  return { ...response, user: userWithRole };
};
```

#### 3. Servicio de Autenticaci√≥n Frontend
**Archivo**: `frontend/my-app/src/services/auth.service.ts`

```typescript
async login(email: string, password: string): Promise<LoginResponse> {
  const response = await api.post('/auth/login', {
    email,
    password,
  });
  
  // Guardar en localStorage
  localStorage.setItem('token', response.data.access_token);
  localStorage.setItem('user', JSON.stringify(response.data.user));
  
  return response.data;
}
```

#### 4. Backend - Controlador
**Archivo**: `backend/src/auth/auth.controller.ts`

```typescript
@Post('login')
async login(@Body(ValidationPipe) loginDto: LoginDto) {
  const user = await this.authService.validateUser(
    loginDto.email,
    loginDto.password,
  );
  
  if (!user) {
    throw new UnauthorizedException('Credenciales inv√°lidas');
  }
  
  return this.authService.login(user);
}
```

#### 5. Backend - Validaci√≥n de Usuario
**Archivo**: `backend/src/auth/auth.service.ts`

```typescript
async validateUser(email: string, password: string): Promise<any> {
  const user = await this.usersRepository.findOne({
    where: { email },
    relations: ['rol'],
  });

  if (!user) {
    return { 
      error: 'USER_NOT_FOUND', 
      message: 'No existe una cuenta registrada con este correo electr√≥nico.' 
    };
  }

  // Verificar email verificado
  if (!user.isVerified) {
    return { 
      error: 'EMAIL_NOT_VERIFIED', 
      message: 'La cuenta no ha sido verificada.'
    };
  }

  // Verificar contrase√±a
  const isPasswordValid = await bcrypt.compare(password, user.password);
  
  if (isPasswordValid) {
    const { password, ...result } = user;
    return result;
  } else {
    return { 
      error: 'INVALID_PASSWORD', 
      message: 'La contrase√±a ingresada es incorrecta.' 
    };
  }
}
```

#### 6. Generaci√≥n del JWT
```typescript
async login(user: any) {
  const payload = {
    email: user.email,
    sub: user.id,
    rol: user.rol.nombre,
  };

  const token = this.jwtService.sign(payload);

  return {
    access_token: token,
    user: {
      id: user.id,
      email: user.email,
      nombre: user.nombre,
      apellido: user.apellido,
      rol: user.rol.nombre,
    },
    redirect: this.getRedirectPath(user.rol.nombre),
  };
}
```

#### 7. Estrategia JWT para Validaci√≥n
**Archivo**: `backend/src/auth/jwt.strategy.ts`

```typescript
async validate(payload: any) {
  const user = await this.usersRepository.findOne({
    where: { id: payload.sub },
    relations: ['rol', 'paciente', 'perfilMedico'],
  });

  if (!user) {
    throw new UnauthorizedException('Usuario no encontrado');
  }

  return user;
}
```

---

## üìÅ Archivos Involucrados

### Frontend (React/TypeScript)

#### üé® P√°ginas (UI)
```
frontend/my-app/src/pages/
‚îú‚îÄ‚îÄ LoginPage.jsx                    # Formulario de inicio de sesi√≥n
‚îú‚îÄ‚îÄ RegisterPage.jsx                 # Formulario de registro
‚îú‚îÄ‚îÄ VerifyEmailPage.jsx             # Verificaci√≥n por c√≥digo email
‚îî‚îÄ‚îÄ VerificationPage.jsx            # P√°gina de verificaci√≥n general
```

#### üß† L√≥gica de Negocio
```
frontend/my-app/src/
‚îú‚îÄ‚îÄ context/
‚îÇ   ‚îî‚îÄ‚îÄ AuthContext.tsx             # Contexto global de autenticaci√≥n
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îú‚îÄ‚îÄ auth.service.ts             # Servicios de autenticaci√≥n
‚îÇ   ‚îî‚îÄ‚îÄ api.js                      # Cliente HTTP configurado
‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îî‚îÄ‚îÄ auth.ts                     # Utilidades de autenticaci√≥n
‚îî‚îÄ‚îÄ hooks/
    ‚îú‚îÄ‚îÄ useAuth.ts                  # Hook personalizado de auth
    ‚îî‚îÄ‚îÄ useAppointmentRequests.ts   # Hooks relacionados con auth
```

#### üõ°Ô∏è Componentes de Protecci√≥n
```
frontend/my-app/src/components/
‚îú‚îÄ‚îÄ ProtectedRoute.jsx              # Rutas protegidas
‚îú‚îÄ‚îÄ AuthModal.jsx                   # Modal de autenticaci√≥n
‚îî‚îÄ‚îÄ AutoRedirect.tsx                # Redirecci√≥n autom√°tica
```

### Backend (NestJS/TypeScript)

#### üéØ Autenticaci√≥n
```
backend/src/auth/
‚îú‚îÄ‚îÄ auth.controller.ts              # Controlador de endpoints de auth
‚îú‚îÄ‚îÄ auth.service.ts                 # L√≥gica de negocio de auth
‚îú‚îÄ‚îÄ auth.module.ts                  # M√≥dulo de autenticaci√≥n
‚îú‚îÄ‚îÄ jwt.strategy.ts                 # Estrategia JWT para Passport
‚îî‚îÄ‚îÄ guards/
    ‚îî‚îÄ‚îÄ jwt-auth.guard.ts           # Guard para proteger rutas
```

#### üìù DTOs (Data Transfer Objects)
```
backend/src/auth/dto/
‚îú‚îÄ‚îÄ login.dto.ts                    # DTO para login
‚îú‚îÄ‚îÄ register.dto.ts                 # DTO para registro
‚îú‚îÄ‚îÄ register-patient-simple.dto.ts # DTO registro paciente simple
‚îú‚îÄ‚îÄ verify.dto.ts                   # DTO para verificaci√≥n
‚îú‚îÄ‚îÄ forgot-password.dto.ts          # DTO recuperar contrase√±a
‚îî‚îÄ‚îÄ reset-password.dto.ts           # DTO resetear contrase√±a
```

#### üë• Entidades
```
backend/src/users/
‚îú‚îÄ‚îÄ entities/
‚îÇ   ‚îî‚îÄ‚îÄ user.entity.ts              # Entidad Usuario con campos de auth
‚îú‚îÄ‚îÄ users.controller.ts             # Controlador de usuarios
‚îî‚îÄ‚îÄ users.service.ts                # Servicio de usuarios
```

#### üîß Configuraci√≥n
```
backend/src/config/
‚îú‚îÄ‚îÄ database.config.ts              # Configuraci√≥n de base de datos
‚îî‚îÄ‚îÄ mail.config.ts                  # Configuraci√≥n de email
```

#### üìß Plantillas de Email
```
backend/src/templates/
‚îú‚îÄ‚îÄ verification-code.hbs           # Plantilla c√≥digo verificaci√≥n
‚îú‚îÄ‚îÄ reset-password.hbs              # Plantilla reset contrase√±a
‚îî‚îÄ‚îÄ password-changed.hbs            # Plantilla contrase√±a cambiada
```

---

## üóÇÔ∏è Estructura de la Base de Datos

### Tabla Users
```sql
CREATE TABLE users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    email VARCHAR(255) UNIQUE NOT NULL,
    password VARCHAR(255) NOT NULL,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100),
    telefono VARCHAR(20),
    rolId INT,
    isVerified BOOLEAN DEFAULT FALSE,
    verificationCode VARCHAR(6),
    isApproved BOOLEAN DEFAULT FALSE,
    approvalStatus ENUM('pending', 'approved', 'rejected') DEFAULT 'pending',
    resetPasswordToken VARCHAR(255),
    resetPasswordExpires DATETIME,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (rolId) REFERENCES roles(id)
);
```

### Tabla Roles
```sql
CREATE TABLE roles (
    id INT PRIMARY KEY AUTO_INCREMENT,
    nombre VARCHAR(50) NOT NULL,
    descripcion TEXT
);

-- Datos iniciales
INSERT INTO roles VALUES 
(1, 'admin', 'Administrador del sistema'),
(2, 'doctor', 'Doctor especialista'),
(3, 'paciente', 'Paciente del sistema');
```

---

## üìä Diagramas de Flujo

### üîê Flujo de Registro

```mermaid
sequenceDiagram
    participant U as Usuario
    participant F as Frontend
    participant B as Backend
    participant DB as Base de Datos
    participant E as Email Service
    
    U->>F: Llena formulario registro
    F->>F: Validaciones frontend
    F->>B: POST /auth/register
    B->>B: Validar datos
    B->>DB: Verificar email √∫nico
    DB-->>B: Email disponible
    B->>B: Hash contrase√±a
    B->>B: Generar c√≥digo 6 d√≠gitos
    B->>DB: Crear usuario (isVerified: false)
    DB-->>B: Usuario creado
    B->>E: Enviar c√≥digo por email
    E-->>B: Email enviado
    B-->>F: {requiresVerification: true}
    F->>F: Redirigir a verificaci√≥n
    
    U->>F: Ingresa c√≥digo recibido
    F->>B: POST /auth/verify
    B->>DB: Buscar usuario por email
    DB-->>B: Usuario encontrado
    B->>B: Validar c√≥digo
    B->>DB: Actualizar isVerified: true
    DB-->>B: Usuario actualizado
    B-->>F: Verificaci√≥n exitosa
    F->>F: Redirigir a login
```

### üîë Flujo de Inicio de Sesi√≥n

```mermaid
sequenceDiagram
    participant U as Usuario
    participant F as Frontend
    participant B as Backend
    participant DB as Base de Datos
    
    U->>F: Ingresa email/password
    F->>F: Validaciones frontend
    F->>B: POST /auth/login
    B->>DB: Buscar usuario por email
    DB-->>B: Usuario encontrado
    B->>B: Verificar isVerified = true
    B->>B: Comparar contrase√±a (bcrypt)
    B->>B: Generar JWT token
    B-->>F: {access_token, user, redirect}
    F->>F: Guardar token en localStorage
    F->>F: Actualizar contexto auth
    F->>F: Redirigir seg√∫n rol
    
    Note over F,B: Peticiones posteriores incluyen<br/>Header: Authorization Bearer <token>
    
    F->>B: GET /api/protected-route
    Note over B: JWT Guard valida token
    B->>B: Decodificar JWT
    B->>DB: Buscar usuario por ID del token
    DB-->>B: Usuario v√°lido
    B-->>F: Respuesta protegida
```

### üõ°Ô∏è Flujo de Validaci√≥n JWT

```mermaid
flowchart TD
    A[Petici√≥n con Token] --> B{Token existe?}
    B -->|No| C[Error 401]
    B -->|S√≠| D[Extraer del Header]
    D --> E[Verificar firma JWT]
    E --> F{Firma v√°lida?}
    F -->|No| G[Error 401]
    F -->|S√≠| H[Decodificar payload]
    H --> I[Obtener user ID del sub]
    I --> J[Buscar usuario en DB]
    J --> K{Usuario existe?}
    K -->|No| L[Error 401]
    K -->|S√≠| M[Usuario v√°lido]
    M --> N[Continuar con petici√≥n]
```

---

## üîí Seguridad

### Medidas Implementadas

#### 1. **Contrase√±as**
- ‚úÖ Hash con **bcrypt** (12 rounds)
- ‚úÖ Validaci√≥n de longitud m√≠nima
- ‚úÖ No se almacenan en texto plano

#### 2. **JWT Tokens**
- ‚úÖ Firmados con **HMAC SHA256**
- ‚úÖ Incluyen fecha de expiraci√≥n
- ‚úÖ Secret key configurable por environment
- ‚úÖ Validaci√≥n en cada petici√≥n protegida

#### 3. **Validaci√≥n de Email**
- ‚úÖ C√≥digo de 6 d√≠gitos aleatorio
- ‚úÖ Verificaci√≥n obligatoria para activar cuenta
- ‚úÖ Plantillas de email profesionales

#### 4. **Protecci√≥n de Rutas**
- ‚úÖ **JwtAuthGuard** en endpoints protegidos
- ‚úÖ **ProtectedRoute** en el frontend
- ‚úÖ Verificaci√≥n de roles por endpoint

#### 5. **Validaci√≥n de Datos**
- ‚úÖ **ValidationPipe** en todos los endpoints
- ‚úÖ DTOs con decoradores de validaci√≥n
- ‚úÖ Sanitizaci√≥n de inputs

#### 6. **Manejo de Errores**
- ‚úÖ Mensajes espec√≠ficos por tipo de error
- ‚úÖ No exposici√≥n de informaci√≥n sensible
- ‚úÖ Logging detallado para debugging

#### 7. **Reset de Contrase√±a**
- ‚úÖ Token √∫nico y temporal (1 hora)
- ‚úÖ Confirmaci√≥n por email
- ‚úÖ Limpieza autom√°tica de tokens expirados

### Configuraci√≥n de Seguridad

#### Variables de Entorno
```env
# JWT
JWT_SECRET=your_super_secret_key_change_in_production
JWT_EXPIRES_IN=24h

# Database
DB_HOST=localhost
DB_PORT=3306
DB_USERNAME=root
DB_PASSWORD=your_password
DB_DATABASE=orto_whave

# Email
MAIL_HOST=smtp.gmail.com
MAIL_PORT=587
MAIL_USERNAME=your_email@gmail.com
MAIL_PASSWORD=your_app_password
```

#### Interceptores y Middleware
```typescript
// Logging de todas las peticiones
@Injectable()
export class LoggingInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const request = context.switchToHttp().getRequest();
    console.log(`${request.method} ${request.url}`);
    return next.handle();
  }
}
```

---

## üöÄ Flujo Completo Resumido

### Registro (Primera vez)
1. **Usuario** ‚Üí Llena formulario ‚Üí **Frontend**
2. **Frontend** ‚Üí Valida datos ‚Üí **Backend** `/auth/register`
3. **Backend** ‚Üí Crea usuario + Env√≠a email ‚Üí **Email Service**
4. **Usuario** ‚Üí Recibe c√≥digo ‚Üí Ingresa en **Frontend**
5. **Frontend** ‚Üí **Backend** `/auth/verify` ‚Üí Cuenta activada ‚úÖ

### Login (Uso normal)
1. **Usuario** ‚Üí Email/Password ‚Üí **Frontend**
2. **Frontend** ‚Üí **Backend** `/auth/login`
3. **Backend** ‚Üí Valida credenciales ‚Üí Genera **JWT**
4. **Frontend** ‚Üí Guarda token ‚Üí Actualiza estado
5. **Usuario** ‚Üí Redirigido al dashboard correspondiente üè†

### Peticiones Protegidas
1. **Frontend** ‚Üí Adjunta `Authorization: Bearer <token>`
2. **Backend** ‚Üí **JWT Guard** valida token
3. **Backend** ‚Üí Ejecuta l√≥gica ‚Üí Respuesta ‚úÖ

---

## üéØ Puntos Clave a Recordar

### Para Desarrolladores Frontend
- üîë **Token se guarda en localStorage**
- üîÑ **AuthContext maneja el estado global**
- üõ°Ô∏è **ProtectedRoute** protege rutas privadas
- üé≠ **Roles determinan la redirecci√≥n**

### Para Desarrolladores Backend  
- üîê **JWT Strategy** valida tokens autom√°ticamente
- üëÆ **Guards** protegen endpoints espec√≠ficos
- üìù **DTOs** validan datos de entrada
- üóÑÔ∏è **Relations** cargan datos relacionados (rol, perfil)

### Para Testing
- üß™ **Credenciales de prueba** disponibles en LoginPage
- üìß **Codes de verificaci√≥n** se loggean en consola (desarrollo)
- üîç **Logs detallados** en AuthService para debugging

---

¬°Con esta documentaci√≥n tienes una visi√≥n completa del flujo de autenticaci√≥n! üéâ

¬øNecesitas que profundice en alg√∫n aspecto espec√≠fico o tienes preguntas sobre la implementaci√≥n?
